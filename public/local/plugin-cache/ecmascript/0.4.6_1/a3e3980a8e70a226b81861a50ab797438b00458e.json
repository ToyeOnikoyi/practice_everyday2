{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/packages/raix:push/lib/server/server.js","filenameRelative":"/packages/raix:push/lib/server/server.js","env":{},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"polyfill":false}],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/packages/raix:push/lib/server/server.js.map","sourceFileName":"/packages/raix:push/lib/server/server.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"basename":"server"},"ignored":false,"code":"Push.appCollection = new Mongo.Collection('_raix_push_app_tokens');\n\nPush.addListener('token', function (currentToken, value) {\n  if (value) {\n    // Update the token for app\n    Push.appCollection.update({ token: currentToken }, { $set: { token: value } }, { multi: true });\n  } else if (value === null) {\n    // Remove the token for app\n    Push.appCollection.update({ token: currentToken }, { $unset: { token: true } }, { multi: true });\n  }\n});\n\nMeteor.methods({\n  'raix:push-update': function raixPushUpdate(options) {\n    if (Push.debug) {\n      console.log('Push: Got push token from app:', options);\n    }\n\n    check(options, {\n      id: Match.Optional(String),\n      token: _matchToken,\n      appName: String,\n      userId: Match.OneOf(String, null),\n      metadata: Match.Optional(Object)\n    });\n\n    // The if user id is set then user id should match on client and connection\n    if (options.userId && options.userId !== this.userId) {\n      throw new Meteor.Error(403, 'Forbidden access');\n    }\n\n    var doc;\n\n    // lookup app by id if one was included\n    if (options.id) {\n      doc = Push.appCollection.findOne({ _id: options.id });\n    }\n\n    // No doc was found - we check the database to see if\n    // we can find a match for the app via token and appName\n    if (!doc) {\n      doc = Push.appCollection.findOne({\n        $and: [{ token: options.token }, // Match token\n        { appName: options.appName }, // Match appName\n        { token: { $exists: true } } // Make sure token exists\n        ]\n      });\n    }\n\n    // if we could not find the id or token then create it\n    if (!doc) {\n      // Rig default doc\n      doc = {\n        token: options.token,\n        appName: options.appName,\n        userId: options.userId,\n        enabled: true,\n        createdAt: new Date(),\n        updatedAt: new Date()\n      };\n\n      if (options.id) {\n        // XXX: We might want to check the id - Why isnt there a match for id\n        // in the Meteor check... Normal length 17 (could be larger), and\n        // numbers+letters are used in Random.id() with exception of 0 and 1\n        doc._id = options.id;\n        // The user wanted us to use a specific id, we didn't find this while\n        // searching. The client could depend on the id eg. as reference so\n        // we respect this and try to create a document with the selected id;\n        Push.appCollection._collection.insert(doc);\n      } else {\n        // Get the id from insert\n        doc._id = Push.appCollection.insert(doc);\n      }\n    } else {\n      // We found the app so update the updatedAt and set the token\n      Push.appCollection.update({ _id: doc._id }, {\n        $set: {\n          updatedAt: new Date(),\n          token: options.token\n        }\n      });\n    }\n\n    if (doc) {\n      // xxx: Hack\n      // Clean up mech making sure tokens are uniq - android sometimes generate\n      // new tokens resulting in duplicates\n      var removed = Push.appCollection.remove({\n        $and: [{ _id: { $ne: doc._id } }, { token: doc.token }, // Match token\n        { appName: doc.appName }, // Match appName\n        { token: { $exists: true } } // Make sure token exists\n        ]\n      });\n\n      if (removed && Push.debug) {\n        console.log('Push: Removed ' + removed + ' existing app items');\n      }\n    }\n\n    if (doc && Push.debug) {\n      console.log('Push: updated', doc);\n    }\n\n    if (!doc) {\n      throw new Meteor.Error(500, 'setPushToken could not create record');\n    }\n    // Return the doc we want to use\n    return doc;\n  },\n  'raix:push-setuser': function raixPushSetuser(id) {\n    check(id, String);\n\n    if (Push.debug) {\n      console.log('Push: Settings userId \"' + this.userId + '\" for app:', id);\n    }\n    // We update the appCollection id setting the Meteor.userId\n    var found = Push.appCollection.update({ _id: id }, { $set: { userId: this.userId } });\n\n    // Note that the app id might not exist because no token is set yet.\n    // We do create the new app id for the user since we might store additional\n    // metadata for the app / user\n\n    // If id not found then create it?\n    // We dont, its better to wait until the user wants to\n    // store metadata or token - We could end up with unused data in the\n    // collection at every app re-install / update\n    //\n    // The user could store some metadata in appCollectin but only if they\n    // have created the app and provided a token.\n    // If not the metadata should be set via ground:db\n\n    return !!found;\n  },\n  'raix:push-metadata': function raixPushMetadata(data) {\n    check(data, {\n      id: String,\n      metadata: Object\n    });\n\n    // Set the metadata\n    var found = Push.appCollection.update({ _id: data.id }, { $set: { metadata: data.metadata } });\n\n    return !!found;\n  },\n  'raix:push-enable': function raixPushEnable(data) {\n    check(data, {\n      id: String,\n      enabled: Boolean\n    });\n\n    if (Push.debug) {\n      console.log('Push: Setting enabled to \"' + data.enabled + '\" for app:', data.id);\n    }\n\n    var found = Push.appCollection.update({ _id: data.id }, { $set: { enabled: data.enabled } });\n\n    return !!found;\n  }\n});","ast":null,"map":{"version":3,"sources":["/packages/raix:push/lib/server/server.js"],"names":[],"mappings":"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","file":"/packages/raix:push/lib/server/server.js.map","sourcesContent":["Push.appCollection = new Mongo.Collection('_raix_push_app_tokens');\n\nPush.addListener('token', function(currentToken, value) {\n  if (value) {\n    // Update the token for app\n    Push.appCollection.update({ token: currentToken }, { $set: { token: value } }, { multi: true });\n  } else if (value === null) {\n    // Remove the token for app\n    Push.appCollection.update({ token: currentToken }, { $unset: { token: true } }, { multi: true });\n  }\n});\n\nMeteor.methods({\n  'raix:push-update': function(options) {\n    if (Push.debug) {\n      console.log('Push: Got push token from app:', options);\n    }\n\n    check(options, {\n      id: Match.Optional(String),\n      token: _matchToken,\n      appName: String,\n      userId: Match.OneOf(String, null),\n      metadata: Match.Optional(Object)\n    });\n\n    // The if user id is set then user id should match on client and connection\n    if (options.userId && options.userId !== this.userId) {\n      throw new Meteor.Error(403, 'Forbidden access');\n    }\n\n    var doc;\n\n    // lookup app by id if one was included\n    if (options.id) {\n      doc = Push.appCollection.findOne({ _id: options.id });\n    }\n\n    // No doc was found - we check the database to see if\n    // we can find a match for the app via token and appName\n    if (!doc) {\n      doc = Push.appCollection.findOne({\n        $and: [\n          { token: options.token },     // Match token\n          { appName: options.appName }, // Match appName\n          { token: { $exists: true } }  // Make sure token exists\n        ]\n      });\n    }\n\n    // if we could not find the id or token then create it\n    if (!doc) {\n      // Rig default doc\n      doc = {\n        token: options.token,\n        appName: options.appName,\n        userId: options.userId,\n        enabled: true,\n        createdAt: new Date(),\n        updatedAt: new Date()\n      };\n\n      if (options.id) {\n        // XXX: We might want to check the id - Why isnt there a match for id\n        // in the Meteor check... Normal length 17 (could be larger), and\n        // numbers+letters are used in Random.id() with exception of 0 and 1\n        doc._id = options.id;\n        // The user wanted us to use a specific id, we didn't find this while\n        // searching. The client could depend on the id eg. as reference so\n        // we respect this and try to create a document with the selected id;\n        Push.appCollection._collection.insert(doc);\n      } else {\n        // Get the id from insert\n        doc._id = Push.appCollection.insert(doc);\n      }\n    } else {\n      // We found the app so update the updatedAt and set the token\n      Push.appCollection.update({ _id: doc._id }, {\n        $set: {\n          updatedAt: new Date(),\n          token: options.token\n        }\n      });\n    }\n\n    if (doc) {\n      // xxx: Hack\n      // Clean up mech making sure tokens are uniq - android sometimes generate\n      // new tokens resulting in duplicates\n      var removed = Push.appCollection.remove({\n        $and: [\n          { _id: { $ne: doc._id } },\n          { token: doc.token },     // Match token\n          { appName: doc.appName }, // Match appName\n          { token: { $exists: true } }  // Make sure token exists\n        ]\n      });\n\n      if (removed && Push.debug) {\n        console.log('Push: Removed ' + removed + ' existing app items');\n      }\n    }\n\n    if (doc && Push.debug) {\n      console.log('Push: updated', doc);\n    }\n\n    if (!doc) {\n      throw new Meteor.Error(500, 'setPushToken could not create record');\n    }\n    // Return the doc we want to use\n    return doc;\n  },\n  'raix:push-setuser': function(id) {\n    check(id, String);\n\n    if (Push.debug) {\n      console.log('Push: Settings userId \"' + this.userId + '\" for app:', id);\n    }\n    // We update the appCollection id setting the Meteor.userId\n    var found = Push.appCollection.update({ _id: id }, { $set: { userId: this.userId } });\n\n    // Note that the app id might not exist because no token is set yet.\n    // We do create the new app id for the user since we might store additional\n    // metadata for the app / user\n\n    // If id not found then create it?\n    // We dont, its better to wait until the user wants to\n    // store metadata or token - We could end up with unused data in the\n    // collection at every app re-install / update\n    //\n    // The user could store some metadata in appCollectin but only if they\n    // have created the app and provided a token.\n    // If not the metadata should be set via ground:db\n\n    return !!found;\n  },\n  'raix:push-metadata': function(data) {\n    check(data, {\n      id: String,\n      metadata: Object\n    });\n\n    // Set the metadata\n    var found = Push.appCollection.update({ _id: data.id }, { $set: { metadata: data.metadata } });\n\n    return !!found;\n  },\n  'raix:push-enable': function(data) {\n    check(data, {\n      id: String,\n      enabled: Boolean\n    });\n\n    if (Push.debug) {\n      console.log('Push: Setting enabled to \"' + data.enabled + '\" for app:', data.id);\n    }\n\n    var found = Push.appCollection.update({ _id: data.id }, { $set: { enabled: data.enabled } });\n\n    return !!found;\n  }\n});\n\n"]},"hash":"a3e3980a8e70a226b81861a50ab797438b00458e"}
