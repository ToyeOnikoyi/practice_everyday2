{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/packages/raix:push/lib/common/notifications.js","filenameRelative":"/packages/raix:push/lib/common/notifications.js","env":{},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"polyfill":false}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":false,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/packages/raix:push/lib/common/notifications.js.map","sourceFileName":"/packages/raix:push/lib/common/notifications.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"basename":"notifications"},"ignored":false,"code":"// Notifications collection\nPush.notifications = new Mongo.Collection('_raix_push_notifications');\n\n// This is a general function to validate that the data added to notifications\n// is in the correct format. If not this function will throw errors\nvar _validateDocument = function _validateDocument(notification) {\n\n  // Check the general notification\n  check(notification, {\n    from: String,\n    title: String,\n    text: String,\n    badge: Match.Optional(Number),\n    sound: Match.Optional(String),\n    notId: Match.Optional(Match.Integer),\n    apn: Match.Optional({\n      from: Match.Optional(String),\n      title: Match.Optional(String),\n      text: Match.Optional(String),\n      badge: Match.Optional(Number),\n      sound: Match.Optional(String),\n      notId: Match.Optional(Match.Integer)\n    }),\n    gcm: Match.Optional({\n      from: Match.Optional(String),\n      title: Match.Optional(String),\n      text: Match.Optional(String),\n      badge: Match.Optional(Number),\n      sound: Match.Optional(String),\n      notId: Match.Optional(Match.Integer)\n    }),\n    query: Match.Optional(String),\n    token: Match.Optional(_matchToken),\n    tokens: Match.Optional([_matchToken]),\n    payload: Match.Optional(Object),\n    delayUntil: Match.Optional(Date),\n    createdAt: Date,\n    createdBy: Match.OneOf(String, null)\n  });\n\n  // Make sure a token selector or query have been set\n  if (!notification.token && !notification.tokens && !notification.query) {\n    throw new Error('No token selector or query found');\n  }\n\n  // If tokens array is set it should not be empty\n  if (notification.tokens && !notification.tokens.length) {\n    throw new Error('No tokens in array');\n  }\n};\n\nPush.send = function (options) {\n  // If on the client we set the user id - on the server we need an option\n  // set or we default to \"<SERVER>\" as the creator of the notification\n  // If current user not set see if we can set it to the logged in user\n  // this will only run on the client if Meteor.userId is available\n  var currentUser = Meteor.isClient && Meteor.userId && Meteor.userId() || Meteor.isServer && (options.createdBy || '<SERVER>') || null;\n\n  // Rig the notification object\n  var notification = _.extend({\n    createdAt: new Date(),\n    createdBy: currentUser\n  }, _.pick(options, 'from', 'title', 'text'));\n\n  // Add extra\n  _.extend(notification, _.pick(options, 'payload', 'badge', 'sound', 'notId', 'delayUntil'));\n\n  if (Match.test(options.apn, Object)) {\n    notification.apn = _.pick(options.apn, 'from', 'title', 'text', 'badge', 'sound', 'notId');\n  }\n\n  if (Match.test(options.gcm, Object)) {\n    notification.gcm = _.pick(options.gcm, 'from', 'title', 'text', 'badge', 'sound', 'notId');\n  }\n\n  // Set one token selector, this can be token, array of tokens or query\n  if (options.query) {\n    // Set query to the json string version fixing #43 and #39\n    notification.query = JSON.stringify(options.query);\n  } else if (options.token) {\n    // Set token\n    notification.token = options.token;\n  } else if (options.tokens) {\n    // Set tokens\n    notification.tokens = options.tokens;\n  }\n\n  // Validate the notification\n  _validateDocument(notification);\n\n  // Try to add the notification to send, we return an id to keep track\n  return Push.notifications.insert(notification);\n};\n\nPush.allow = function (rules) {\n  if (rules.send) {\n    Push.notifications.allow({\n      'insert': function () {\n        function insert(userId, notification) {\n          // Validate the notification\n          _validateDocument(notification);\n          // Set the user defined \"send\" rules\n          return rules.send.apply(this, [userId, notification]);\n        }\n\n        return insert;\n      }()\n    });\n  }\n};\n\nPush.deny = function (rules) {\n  if (rules.send) {\n    Push.notifications.deny({\n      'insert': function () {\n        function insert(userId, notification) {\n          // Validate the notification\n          _validateDocument(notification);\n          // Set the user defined \"send\" rules\n          return rules.send.apply(this, [userId, notification]);\n        }\n\n        return insert;\n      }()\n    });\n  }\n};","ast":null,"map":{"version":3,"sources":["/packages/raix:push/lib/common/notifications.js"],"names":[],"mappings":"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","file":"/packages/raix:push/lib/common/notifications.js.map","sourcesContent":["// Notifications collection\nPush.notifications = new Mongo.Collection('_raix_push_notifications');\n\n// This is a general function to validate that the data added to notifications\n// is in the correct format. If not this function will throw errors\nvar _validateDocument = function(notification) {\n\n  // Check the general notification\n  check(notification, {\n    from: String,\n    title: String,\n    text: String,\n    badge: Match.Optional(Number),\n    sound: Match.Optional(String),\n    notId: Match.Optional(Match.Integer),\n    apn: Match.Optional({\n      from: Match.Optional(String),\n      title: Match.Optional(String),\n      text: Match.Optional(String),\n      badge: Match.Optional(Number),\n      sound: Match.Optional(String),\n      notId: Match.Optional(Match.Integer)\n    }),\n    gcm: Match.Optional({\n      from: Match.Optional(String),\n      title: Match.Optional(String),\n      text: Match.Optional(String),\n      badge: Match.Optional(Number),\n      sound: Match.Optional(String),\n      notId: Match.Optional(Match.Integer)\n    }),\n    query: Match.Optional(String),\n    token: Match.Optional(_matchToken),\n    tokens: Match.Optional([_matchToken]),\n    payload: Match.Optional(Object),\n    delayUntil: Match.Optional(Date),\n    createdAt: Date,\n    createdBy: Match.OneOf(String, null)\n  });\n\n  // Make sure a token selector or query have been set\n  if (!notification.token && !notification.tokens && !notification.query) {\n    throw new Error('No token selector or query found');\n  }\n\n  // If tokens array is set it should not be empty\n  if (notification.tokens && !notification.tokens.length) {\n    throw new Error('No tokens in array');\n  }\n};\n\nPush.send = function(options) {\n  // If on the client we set the user id - on the server we need an option\n  // set or we default to \"<SERVER>\" as the creator of the notification\n  // If current user not set see if we can set it to the logged in user\n  // this will only run on the client if Meteor.userId is available\n  var currentUser = Meteor.isClient && Meteor.userId && Meteor.userId() ||\n          Meteor.isServer && (options.createdBy || '<SERVER>') || null;\n\n  // Rig the notification object\n   var notification = _.extend({\n    createdAt: new Date(),\n    createdBy: currentUser\n  }, _.pick(options, 'from', 'title', 'text'));\n\n   // Add extra\n   _.extend(notification, _.pick(options, 'payload', 'badge', 'sound', 'notId', 'delayUntil'));\n\n  if (Match.test(options.apn, Object)) {\n    notification.apn = _.pick(options.apn, 'from', 'title', 'text', 'badge', 'sound', 'notId');\n  }\n\n  if (Match.test(options.gcm, Object)) {\n    notification.gcm = _.pick(options.gcm, 'from', 'title', 'text', 'badge', 'sound', 'notId');\n  }\n\n  // Set one token selector, this can be token, array of tokens or query\n  if (options.query) {\n    // Set query to the json string version fixing #43 and #39\n    notification.query = JSON.stringify(options.query);\n  } else if (options.token) {\n    // Set token\n    notification.token = options.token;\n  } else if (options.tokens) {\n    // Set tokens\n    notification.tokens = options.tokens;\n  }\n\n  // Validate the notification\n  _validateDocument(notification);\n\n  // Try to add the notification to send, we return an id to keep track\n  return Push.notifications.insert(notification);\n};\n\nPush.allow = function(rules) {\n  if (rules.send) {\n    Push.notifications.allow({\n      'insert': function(userId, notification) {\n        // Validate the notification\n        _validateDocument(notification);\n        // Set the user defined \"send\" rules\n        return rules.send.apply(this, [userId, notification]);\n      }\n    });\n  }\n};\n\nPush.deny = function(rules) {\n  if (rules.send) {\n    Push.notifications.deny({\n      'insert': function(userId, notification) {\n        // Validate the notification\n        _validateDocument(notification);\n        // Set the user defined \"send\" rules\n        return rules.send.apply(this, [userId, notification]);\n      }\n    });\n  }\n};\n"]},"hash":"fbb24d2e4cc3838b6994ba6aafc23ee50331a038"}
